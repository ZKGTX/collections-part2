package com.zerokikr.lesson5.collections;

/* HashMap имеет capacity равный степени двойки, произвольный capacity задать не получится. 
 *
 * При добавлении (.put) пары ключ-значение в HashMap вычисляется hashCode() ключа и совмещается с
 * 	   емкостью (capacity), получается число от 0 до (capacity - 1),
 * 	   которое и станет индексом пары внутри таблицы HashMap.
 * 	   Принцип совмещения отличается в разных версиях JDK.
 * 
 * При поиске по ключу вновь вычисляется hashCode() ключа и совмещается с
 * 	   емкостью (capacity), прицельно находится нужная ячейка.
 * 
 * В случае коллизии (одинаковый индекс у двух и более пар) в ячейке выстраивается LinkedList
 * 	 со всеми парами. При большом количестве пар в ячейке HashMap перестраивает LinkedList в Tree.
 * 	 Чем меньше коллизий тем выше скорость работы.
 *
 * Емкость HashMap увеличивается в два раза при превышении loadFactor (по умолчанию 0,75) * capacity.
 * 	 В момент увеличения емкости происходит перехеширование записей.
 * 	 Маленький loadFactor - быстрый HashMap, быстрый поиск, сильное распределение, съест много памяти.
 * 	 Большой loadFactor - потребует мало памяти, но много коллизий (слабое распределение), медленный поиск.
 * 
 * HashMap не гарантирует порядок выдачи пар при выводе. Не синхронизирован.
 *  Выдает мн-во результатов в виде EntrySet.
 *  
 * LinkedHashMap сохраняет порядок добавленных пар.
 * 
 * TreeMap сортирует пары по ключу.
 * 
 * HashTable - устаревший тип HashMap. Синхронизирован.
 *  Выдает множество результатов в виде Enumeration.  
 *  
 */

 

public class HashMapInfo {

}
